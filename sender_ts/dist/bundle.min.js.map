{"version":3,"file":"bundle.min.js","sources":["../src/logger.ts","../src/remote_target.ts","../src/util.ts","../src/cast_sender.ts","../src/config.ts","../src/index.ts"],"sourcesContent":["class LoggerWriter {\n  public debug(...args: any[]) {\n    console.debug(...args);\n  }\n\n  public error(...args: any[]) {\n    console.error(...args);\n  }\n\n  public info(...args: any[]) {\n    console.info(...args);\n  }\n\n  public warn(...args: any[]) {\n    console.warn(...args);\n  }\n}\n\nexport class Logger {\n  private static logger: LoggerWriter;\n  private name: string;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  static init() {\n    Logger.logger = new LoggerWriter();\n  }\n\n  public debug(...args: any[]) {\n    console.log(this.name, ...args);\n    Logger.logger.debug(this.name, ...args);\n  }\n\n  public error(...args: any[]) {\n    Logger.logger.error(this.name, ...args);\n  }\n\n  public info(...args: any[]) {\n    Logger.logger.info(this.name, ...args);\n  }\n\n  public warn(...args: any[]) {\n    Logger.logger.warn(this.name, ...args);\n  }\n}\n","import { Drm } from \"./drm\";\nimport { PlayerTarget } from \"./player_target\";\nimport { getErrorMessage, getMediaTimeString } from \"./util\";\n\nexport class RemoteTarget implements PlayerTarget {\n  private remotePlayer: cast.framework.RemotePlayer;\n  private remotePlayerController: cast.framework.RemotePlayerController;\n  private currentMediaTime: number;\n  private mediaInfo: chrome.cast.media.MediaInfo | null;\n  private isLiveContent: boolean;\n  public target?: PlayerTarget;\n  public currentMediaInfo?: any;\n  public context: cast.framework.CastContext;\n\n  constructor(\n    remotePlayer: cast.framework.RemotePlayer,\n    remotePlayerController: cast.framework.RemotePlayerController,\n    context: cast.framework.CastContext,\n  ) {\n    this.remotePlayer = remotePlayer;\n    this.remotePlayerController = remotePlayerController;\n    this.currentMediaTime = 0;\n    this.mediaInfo = null;\n    this.isLiveContent = false;\n    this.context = context;\n  }\n\n  public play() {\n    if (this.remotePlayer.isPaused) {\n      this.remotePlayerController.playOrPause();\n    }\n  }\n\n  public pause() {\n    if (!this.remotePlayer.isPaused) {\n      this.remotePlayerController.playOrPause();\n    }\n  }\n\n  public stop() {\n    this.remotePlayerController.stop();\n  }\n\n  // Load request for local -> remote\n  public load(url: string, drm?: Drm) {\n    console.log(\"Loading...\", url, drm);\n\n    let mediaInfo = new chrome.cast.media.MediaInfo(url, \"\");\n    if (drm) {\n      mediaInfo.customData = { drm };\n    }\n    mediaInfo.metadata = new chrome.cast.media.GenericMediaMetadata();\n    mediaInfo.metadata.title = \"TODO TITLE\";\n    mediaInfo.metadata.subtitle = \"TODO SUBTITLE\";\n    // mediaInfo.streamType = chrome.cast.media.StreamType.BUFFERED;\n\n    // mediaInfo.metadata.images = [\n    //   {\n    //     url: MEDIA_SOURCE_ROOT + this.mediaContents[mediaIndex][\"thumb\"],\n    //   },\n    // ];\n\n    // Change the streamType and add live specific metadata.\n    // mediaInfo.streamType = chrome.cast.media.StreamType.LIVE;\n    // TODO: Set the metadata on the receiver side in your implementation.\n    // startAbsoluteTime and sectionStartTimeInMedia will be set for you.\n    // See https://developers.google.com/cast/docs/caf_receiver/live.\n\n    // TODO: Start time, is a fake timestamp. Use correct values for your implementation.\n    // let currentTime = new Date();\n    // Convert from milliseconds to seconds.\n    // let miliseconds = currentTime.getTime() / 1000;\n    // let sectionStartAbsoluteTime = miliseconds;\n\n    // Duration should be -1 for live streams.\n    // mediaInfo.duration = -1;\n    // TODO: Set on the receiver for your implementation.\n    //   mediaInfo.startAbsoluteTime = miliseconds; TODO\n    // mediaInfo.metadata.sectionStartAbsoluteTime = sectionStartAbsoluteTime;\n    // TODO: Set on the receiver for your implementation.\n    // mediaInfo.metadata.sectionStartTimeInMedia = 0;\n    // mediaInfo.metadata.sectionDuration = 100; // TODO Duration;\n\n    let request = new chrome.cast.media.LoadRequest(mediaInfo);\n    request.currentTime = this.currentMediaTime;\n    request.autoplay = true;\n\n    this.context\n      .getCurrentSession()\n      ?.loadMedia(request)\n      .then(\n        () => {\n          console.log(\"Remote media loaded\");\n        },\n        (errorCode) => {\n          console.log(\"Remote media load error: \" + getErrorMessage(errorCode));\n          //   this.playerHandler.updateDisplay();\n        },\n      );\n  }\n\n  public isMediaLoaded(url: string) {\n    let session = this.context.getCurrentSession();\n    if (!session) return false;\n\n    let media = session.getMediaSession();\n    if (!media) return false;\n\n    // No need to verify local mediaIndex content.\n    return true;\n  }\n\n  /**\n   * @return {number?} Current media time for the content. Always returns\n   *      media time even if in clock time (conversion done when displaying).\n   */\n  public getCurrentMediaTime() {\n    if (this.isLiveContent && this.mediaInfo?.metadata && this.mediaInfo.metadata.sectionStartTimeInMedia) {\n      return this.remotePlayer.currentTime - this.mediaInfo.metadata.sectionStartTimeInMedia;\n    } else {\n      // VOD and live scenerios where live metadata is not provided.\n      return this.remotePlayer.currentTime;\n    }\n  }\n\n  /**\n   * @return {number?} media time duration for the content. Always returns\n   *      media time even if in clock time (conversion done when displaying).\n   */\n  public getMediaDuration() {\n    if (this.isLiveContent) {\n      // Scenerios when live metadata is not provided.\n      if (\n        this.mediaInfo?.metadata == undefined ||\n        this.mediaInfo.metadata.sectionDuration == undefined ||\n        this.mediaInfo.metadata.sectionStartTimeInMedia == undefined\n      ) {\n        return null;\n      }\n\n      return this.mediaInfo.metadata.sectionDuration;\n    } else {\n      return this.remotePlayer.duration;\n    }\n  }\n\n  public updateDisplay() {\n    let castSession = this.context.getCurrentSession();\n    if (castSession && castSession.getMediaSession() && castSession.getMediaSession()?.media) {\n      let media = castSession.getMediaSession();\n      let mediaInfo = media?.media;\n\n      // image placeholder for video view\n      let previewImage: string | null = null;\n      if (mediaInfo?.metadata && mediaInfo.metadata.images && mediaInfo.metadata.images.length > 0) {\n        previewImage = mediaInfo.metadata.images[0].url;\n      } else {\n        previewImage = null;\n      }\n\n      let mediaTitle = \"\";\n      let mediaEpisodeTitle = \"\";\n      let mediaSubtitle = \"\";\n\n      let mediaState = mediaTitle + \" on \" + castSession.getCastDevice().friendlyName;\n\n      if (mediaInfo?.metadata) {\n        mediaTitle = mediaInfo.metadata.title;\n        mediaEpisodeTitle = mediaInfo.metadata.episodeTitle;\n        // Append episode title if present\n        mediaTitle = mediaEpisodeTitle ? mediaTitle + \": \" + mediaEpisodeTitle : mediaTitle;\n        // Do not display mediaTitle if not defined.\n        mediaTitle = mediaTitle ? mediaTitle + \" \" : \"\";\n        mediaSubtitle = mediaInfo.metadata.subtitle;\n        mediaSubtitle = mediaSubtitle ? mediaSubtitle + \" \" : \"\";\n      }\n    }\n  }\n\n  public updateCurrentTimeDisplay() {\n    this.setTimeString(this.getCurrentMediaTime() ?? 0);\n  }\n\n  public updateDurationDisplay() {\n    this.setTimeString(this.getMediaDuration() ?? 0);\n  }\n\n  public setTimeString(time: number) {\n    let currentTimeString = getMediaTimeString(time);\n    // TODO\n  }\n\n  // 0 to 1\n  public setVolume(volume: number) {\n    this.remotePlayer.volumeLevel = volume;\n    this.remotePlayerController.setVolumeLevel();\n  }\n\n  public mute() {\n    if (!this.remotePlayer.isMuted) {\n      this.remotePlayerController.muteOrUnmute();\n    }\n  }\n\n  public unMute() {\n    if (this.remotePlayer.isMuted) {\n      this.remotePlayerController.muteOrUnmute();\n    }\n  }\n\n  public isMuted() {\n    return this.remotePlayer.isMuted;\n  }\n\n  public seekTo(time: number) {\n    this.remotePlayer.currentTime = time;\n    this.remotePlayerController.seek();\n  }\n}\n","/**\n * @param {?number} timestamp Linux timestamp\n * @return {?string} media time string. Null if time is invalid.\n */\nexport function getMediaTimeString(timestamp: number) {\n  if (timestamp == undefined || timestamp == null) {\n    return null;\n  }\n\n  let isNegative = false;\n  if (timestamp < 0) {\n    isNegative = true;\n    timestamp *= -1;\n  }\n\n  let hours = Math.floor(timestamp / 3600);\n  let minutes = Math.floor((timestamp - hours * 3600) / 60);\n  let seconds = Math.floor(timestamp - hours * 3600 - minutes * 60);\n\n  let hoursText = hours.toString();\n  let minutesText = minutes.toString();\n  let secondsText = seconds.toString();\n\n  if (hours < 10) hoursText = \"0\" + hours;\n  if (minutes < 10) minutesText = \"0\" + minutes;\n  if (seconds < 10) secondsText = \"0\" + seconds;\n\n  return (isNegative ? \"-\" : \"\") + hoursText + \":\" + minutesText + \":\" + secondsText;\n}\n\n/**\n * @param {number} timestamp Linux timestamp\n * @return {?string} ClockTime string. Null if time is invalid.\n */\nexport function getClockTimeString(timestamp: number) {\n  if (!timestamp) return \"0:00:00\";\n\n  let date = new Date(timestamp * 1000);\n  let hours = date.getHours();\n  let minutes = date.getMinutes();\n  let seconds = date.getSeconds();\n  let ampm = hours >= 12 ? \"PM\" : \"AM\";\n  hours = hours % 12;\n  // Hour '0' should be '12'\n  hours = hours ? hours : 12;\n  const minutesText = (\"0\" + minutes).slice(-2);\n  const secondsText = (\"0\" + seconds).slice(-2);\n  let clockTime = hours + \":\" + minutesText + \":\" + secondsText + \" \" + ampm;\n  return clockTime;\n}\n\n/**\n * Makes human-readable message from chrome.cast.Error\n * @param {chrome.cast.Error} error\n * @return {string} error message\n */\nexport function getErrorMessage(error: chrome.cast.Error) {\n  switch (error.code) {\n    case chrome.cast.ErrorCode.API_NOT_INITIALIZED:\n      return \"The API is not initialized.\" + (error.description ? \" :\" + error.description : \"\");\n    case chrome.cast.ErrorCode.CANCEL:\n      return \"The operation was canceled by the user\" + (error.description ? \" :\" + error.description : \"\");\n    case chrome.cast.ErrorCode.CHANNEL_ERROR:\n      return \"A channel to the receiver is not available.\" + (error.description ? \" :\" + error.description : \"\");\n    case chrome.cast.ErrorCode.EXTENSION_MISSING:\n      return \"The Cast extension is not available.\" + (error.description ? \" :\" + error.description : \"\");\n    case chrome.cast.ErrorCode.INVALID_PARAMETER:\n      return \"The parameters to the operation were not valid.\" + (error.description ? \" :\" + error.description : \"\");\n    case chrome.cast.ErrorCode.RECEIVER_UNAVAILABLE:\n      return (\n        \"No receiver was compatible with the session request.\" + (error.description ? \" :\" + error.description : \"\")\n      );\n    case chrome.cast.ErrorCode.SESSION_ERROR:\n      return (\n        \"A session could not be created, or a session was invalid.\" +\n        (error.description ? \" :\" + error.description : \"\")\n      );\n    case chrome.cast.ErrorCode.TIMEOUT:\n      return \"The operation timed out.\" + (error.description ? \" :\" + error.description : \"\");\n    default:\n      return error;\n  }\n}\n","import \"chromecast-caf-sender\";\nimport { Logger } from \"./logger\";\nimport { APP_ID, TIMER_STEP } from \"./config\";\nimport { RemoteTarget } from \"./remote_target\";\nimport { PlayerTarget } from \"./player_target\";\n\n/**\n * Cast player object\n * Main variables:\n *  - PlayerHandler object for handling media playback\n *  - Cast player variables for controlling Cast mode media playback\n *  - Current media variables for transition between Cast and local modes\n *  - Current ad variables for controlling UI based on ad playback\n *  - Current live variables for controlling UI based on ad playback\n * @struct @constructor\n */\nexport class CastPlayer {\n  public logger: Logger;\n  public player!: PlayerTarget;\n  public remotePlayer?: cast.framework.RemotePlayer | null;\n  public remotePlayerController?: cast.framework.RemotePlayerController | null;\n  public currentMediaTime?: number | null;\n  public mediaDuration?: number | null;\n  public timer?: number | null;\n  public incrementMediaTimeHandler?: Function | null;\n  public seekMediaListener?: Function | null;\n  public currentMediaUrl?: string | null;\n\n  public mediaInfo?: chrome.cast.media.MediaInfo | null;\n  public liveSeekableRange?: chrome.cast.media.LiveSeekableRange | null;\n  public isLiveContent?: boolean | null;\n  public context!: cast.framework.CastContext;\n\n  constructor() {\n    /** @type {PlayerHandler} Delegation proxy for media playback */\n    // this.player = null;\n\n    /* Cast player variables */\n    /** @type {cast.framework.RemotePlayer} */\n    this.remotePlayer = null;\n    /** @type {cast.framework.RemotePlayerController} */\n    this.remotePlayerController = null;\n\n    /* Local+Remote player variables */\n    /** @type {number} A number for current time in seconds. Maintained in media time. */\n    this.currentMediaTime = 0;\n    /**\n     * @type {?number} A number for current duration in seconds. Maintained in media time.\n     * Null if duration should not be shown.\n     */\n    this.mediaDuration = -1;\n\n    /** @type {?number} A timer for tracking progress of media */\n    this.timer = null;\n    /** @type {function()} Listener for handling current time increments */\n    this.incrementMediaTimeHandler = this.incrementMediaTime.bind(this);\n    /** @type {function()} Listener to be added/removed for the seek action */\n    this.seekMediaListener = this.seekMedia.bind(this);\n\n    /* Local player variables */\n    /** @type {number} A number for current media index */\n    this.currentMediaUrl = \"\";\n\n    /* Remote Player variables */\n    /** @type {?chrome.cast.media.MediaInfo} Current mediaInfo */\n    this.mediaInfo = null;\n\n    /* Live variables */\n    /** @type {?chrome.cast.media.LiveSeekableRange} Seekable range for live content */\n    this.liveSeekableRange = null;\n    /** @type {boolean} Remote player is playing live content. */\n    this.isLiveContent = false;\n\n    this.logger = new Logger(\"CastPlayer\");\n  }\n\n  public viewElement() {\n    this.logger.debug(\"[Player viewElement]\");\n    const castButton = document.createElement(\"google-cast-launcher\");\n    castButton.id = \"cast_button\";\n\n    return castButton;\n  }\n\n  public initializeCastPlayer() {\n    this.logger.debug(\"initializeCastPlayer\");\n    this.context = cast.framework.CastContext.getInstance();\n    const options: cast.framework.CastOptions = {\n      // Set the receiver application ID to your own (created in the\n      // Google Cast Developer Console), or optionally\n      // use the chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID\n      receiverApplicationId: APP_ID,\n      // Auto join policy can be one of the following three:\n      // ORIGIN_SCOPED - Auto connect from same appId and page origin\n      // TAB_AND_ORIGIN_SCOPED - Auto connect from same appId, page origin, and tab\n      // PAGE_SCOPED - No auto connect\n      autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED,\n    };\n\n    this.context.setOptions(options);\n\n    this.remotePlayer = new cast.framework.RemotePlayer();\n    this.remotePlayerController = new cast.framework.RemotePlayerController(this.remotePlayer);\n    this.remotePlayerController.addEventListener(cast.framework.RemotePlayerEventType.IS_CONNECTED_CHANGED, (e) => {\n      this.logger.debug(\"RemotePlayerController.IS_CONNECTED_CHANGED\");\n      this.stopProgressTimer();\n      // Session is active\n      if (cast && cast.framework && this.remotePlayer?.isConnected) {\n        this.setupRemotePlayer();\n      }\n    });\n    this.player = new RemoteTarget(this.remotePlayer, this.remotePlayerController, this.context);\n  }\n\n  public prepareToPlay() {\n    this.mediaDuration = this.player.getMediaDuration();\n    this.player.updateDurationDisplay();\n\n    this.player.play();\n    this.startProgressTimer();\n    this.player.updateDisplay();\n  }\n\n  /**\n   * Set the PlayerHandler target to use the remote player\n   * Add event listeners for player changes which may occur outside sender app.\n   */\n  public setupRemotePlayer() {\n    this.logger.debug(\"setupRemotePlayer\");\n    // Triggers when the media info or the player state changes\n    this.remotePlayerController?.addEventListener(cast.framework.RemotePlayerEventType.MEDIA_INFO_CHANGED, (event) => {\n      this.logger.debug(\"RemotePlayer.MEDIA_INFO_CHANGED\", event);\n      let session = this.context.getCurrentSession();\n      if (!session) {\n        this.mediaInfo = null;\n        this.isLiveContent = false;\n        this.player.updateDisplay();\n        return;\n      }\n\n      let media = session.getMediaSession();\n      if (!media) {\n        this.mediaInfo = null;\n        this.isLiveContent = false;\n        this.player.updateDisplay();\n        return;\n      }\n\n      this.mediaInfo = media.media;\n\n      if (this.mediaInfo) {\n        this.isLiveContent = this.mediaInfo.streamType == chrome.cast.media.StreamType.LIVE;\n      } else {\n        this.isLiveContent = false;\n      }\n\n      this.prepareToPlay();\n\n      this.player.updateDisplay();\n    });\n\n    this.remotePlayerController?.addEventListener(cast.framework.RemotePlayerEventType.CAN_SEEK_CHANGED, (event) => {\n      this.logger.debug(\"RemotePlayer.CAN_SEEK_CHANGED\", event);\n    });\n\n    this.remotePlayerController?.addEventListener(cast.framework.RemotePlayerEventType.IS_PAUSED_CHANGED, () => {\n      this.logger.debug(\"RemotePlayer.IS_PAUSED_CHANGED\", this.remotePlayer?.isPaused);\n      if (this.remotePlayer?.isPaused) {\n        this.player.pause();\n      } else {\n        // If currently not playing, start to play.\n        // This occurs if starting to play from local, but this check is\n        // required if the state is changed remotely.\n        this.player.play();\n      }\n    });\n\n    this.remotePlayerController?.addEventListener(cast.framework.RemotePlayerEventType.IS_MUTED_CHANGED, () => {\n      this.logger.debug(\"RemotePlayer.IS_MUTED_CHANGED\", this.remotePlayer?.isMuted);\n      if (this.remotePlayer?.isMuted) {\n        this.player.mute();\n      } else {\n        this.player.unMute();\n      }\n    });\n\n    this.remotePlayerController?.addEventListener(cast.framework.RemotePlayerEventType.VOLUME_LEVEL_CHANGED, () => {\n      this.logger.debug(\"RemotePlayer.VOLUME_LEVEL_CHANGED\", this.remotePlayer?.volumeLevel);\n    });\n\n    this.remotePlayerController?.addEventListener(\n      cast.framework.RemotePlayerEventType.LIVE_SEEKABLE_RANGE_CHANGED,\n      (event) => {\n        console.log(\"LIVE_SEEKABLE_RANGE_CHANGED\");\n        this.liveSeekableRange = event.value;\n      },\n    );\n\n    // Setup remote player properties on setup\n    if (this.remotePlayer?.isMuted) {\n      this.player.mute();\n    }\n\n    // The remote player may have had a volume set from previous playback\n    // TODO update volume\n\n    // If resuming a session, take the remote properties and continue the existing\n    // playback. Otherwise, load local content.\n    if (this.context.getCurrentSession()?.getSessionState() == cast.framework.SessionState.SESSION_RESUMED) {\n      console.log(\"Resuming session\");\n      this.prepareToPlay();\n    } else {\n      // this.playerHandler.load(url);\n    }\n  }\n\n  /**\n   * Select a media content\n   * @param {number} mediaIndex A number for media index\n   */\n  public selectMedias(url: string) {\n    console.log(\"Media index selected: \" + url);\n\n    this.currentMediaUrl = url;\n\n    // Stop timer and reset time displays\n    this.stopProgressTimer();\n    this.currentMediaTime = 0;\n    this.player.setTimeString(0);\n    this.player.setTimeString(0);\n    this.player.play();\n  }\n\n  /**\n   * Media seek function\n   * @param {Event} event An event object from seek\n   */\n  public seekMedia(seekTime: number) {\n    if (this.mediaDuration == null || (this.context.getCurrentSession() && !this.remotePlayer?.canSeek)) {\n      console.log(\"Error - Not seekable\");\n      return;\n    }\n\n    if (this.isLiveContent && !this.liveSeekableRange) {\n      console.log(\"Live content has no seekable range.\");\n      return;\n    }\n\n    this.currentMediaTime = seekTime;\n\n    if (this.isLiveContent) {\n      seekTime += this.mediaInfo?.metadata.sectionStartTimeInMedia;\n    }\n\n    this.player.seekTo(seekTime);\n  }\n\n  /**\n   * Set current player volume\n   * @param {Event} mouseEvent\n   */\n  public setVolume(pos: number) {\n    this.player.setVolume(pos);\n  }\n\n  /**\n   * Starts the timer to increment the media progress bar\n   */\n  public startProgressTimer() {\n    this.stopProgressTimer();\n\n    // Start progress timer\n    this.timer = setInterval(this.incrementMediaTimeHandler!, TIMER_STEP);\n  }\n\n  /**\n   * Stops the timer to increment the media progress bar\n   */\n  public stopProgressTimer() {\n    if (this.timer) {\n      clearInterval(this.timer);\n      this.timer = null;\n    }\n  }\n\n  /**\n   * Increment media current time depending on remote or local playback\n   */\n  public incrementMediaTime() {\n    // First sync with the current player's time\n    this.currentMediaTime = this.player.getCurrentMediaTime();\n    this.mediaDuration = this.player.getMediaDuration();\n\n    this.player.updateDurationDisplay();\n\n    if (this.mediaDuration == null || this.currentMediaTime! < this.mediaDuration || this.isLiveContent) {\n      this.player.updateCurrentTimeDisplay();\n      this.updateProgressBarByTimer();\n    } else if (this.mediaDuration > 0) {\n      this.endPlayback();\n    }\n  }\n\n  /**\n   * Update progress bar and currentTime based on timer\n   */\n  public updateProgressBarByTimer() {\n    // Live situation where the progress and duration is unknown.\n    if (this.mediaDuration == null) {\n      if (!this.isLiveContent) {\n        console.log(\"Error - Duration is not defined for a VOD stream.\");\n      }\n\n      const progress = 0;\n      return;\n    }\n\n    if (this.isLiveContent) {\n      if (this.liveSeekableRange) {\n        // Use the liveSeekableRange to draw the seekable and unseekable windows\n        let seekableMediaPosition =\n          Math.max(this.mediaInfo?.metadata.sectionStartTimeInMedia, this.liveSeekableRange.end!) -\n          this.mediaInfo?.metadata.sectionStartTimeInMedia;\n\n        let unseekableMediaPosition =\n          Math.max(this.mediaInfo?.metadata.sectionStartTimeInMedia, this.liveSeekableRange.start!) -\n          this.mediaInfo?.metadata.sectionStartTimeInMedia;\n      }\n    }\n\n    var pp = Math.floor(this.currentMediaTime! / this.mediaDuration);\n    if (pp > 1) {\n      pp = 1;\n    } else if (pp < 0) {\n      pp = 0;\n    }\n\n    if (pp >= 1 && !this.isLiveContent) {\n      this.endPlayback();\n    }\n  }\n\n  /**\n   *  End playback. Called when media ends.\n   */\n  public endPlayback() {\n    this.currentMediaTime = 0;\n    this.stopProgressTimer();\n    this.player.updateDisplay();\n  }\n}\n","// export const APP_ID = \"72A0DA66\";\nexport const APP_ID = \"CE104983\";\n\n/**\n * Time in milliseconds for minimal progress update.\n * @const {number}\n */\nexport const TIMER_STEP = 1000;\n","import { CastPlayer } from \"./cast_sender\";\nimport { Logger } from \"./logger\";\n\nLogger.init();\n\nlet castPlayer = new CastPlayer();\nwindow[\"__onGCastApiAvailable\"] = function (isAvailable: boolean) {\n  if (isAvailable) {\n    castPlayer.initializeCastPlayer();\n  }\n};\n\nexport { castPlayer, CastPlayer };\n"],"names":["LoggerWriter","debug","args","console","error","info","warn","Logger","constructor","name","this","init","logger","log","RemoteTarget","remotePlayer","remotePlayerController","context","currentMediaTime","mediaInfo","isLiveContent","play","isPaused","playOrPause","pause","stop","load","url","drm","chrome","cast","media","MediaInfo","customData","metadata","GenericMediaMetadata","title","subtitle","request","LoadRequest","currentTime","autoplay","_a","getCurrentSession","loadMedia","then","errorCode","code","ErrorCode","API_NOT_INITIALIZED","description","CANCEL","CHANNEL_ERROR","EXTENSION_MISSING","INVALID_PARAMETER","RECEIVER_UNAVAILABLE","SESSION_ERROR","TIMEOUT","getErrorMessage","isMediaLoaded","session","getMediaSession","getCurrentMediaTime","sectionStartTimeInMedia","getMediaDuration","undefined","sectionDuration","duration","updateDisplay","castSession","images","length","mediaTitle","mediaEpisodeTitle","getCastDevice","friendlyName","episodeTitle","updateCurrentTimeDisplay","setTimeString","updateDurationDisplay","time","timestamp","isNegative","hours","Math","floor","minutes","seconds","hoursText","toString","minutesText","secondsText","getMediaTimeString","setVolume","volume","volumeLevel","setVolumeLevel","mute","isMuted","muteOrUnmute","unMute","seekTo","seek","CastPlayer","mediaDuration","timer","incrementMediaTimeHandler","incrementMediaTime","bind","seekMediaListener","seekMedia","currentMediaUrl","liveSeekableRange","viewElement","castButton","document","createElement","id","initializeCastPlayer","framework","CastContext","getInstance","options","receiverApplicationId","autoJoinPolicy","AutoJoinPolicy","ORIGIN_SCOPED","setOptions","RemotePlayer","RemotePlayerController","addEventListener","RemotePlayerEventType","IS_CONNECTED_CHANGED","e","stopProgressTimer","isConnected","setupRemotePlayer","player","prepareToPlay","startProgressTimer","MEDIA_INFO_CHANGED","event","streamType","StreamType","LIVE","_b","CAN_SEEK_CHANGED","_c","IS_PAUSED_CHANGED","_d","IS_MUTED_CHANGED","_e","VOLUME_LEVEL_CHANGED","_f","LIVE_SEEKABLE_RANGE_CHANGED","value","_g","_h","getSessionState","SessionState","SESSION_RESUMED","selectMedias","seekTime","canSeek","pos","setInterval","clearInterval","updateProgressBarByTimer","endPlayback","max","end","start","pp","castPlayer","window","isAvailable"],"mappings":"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"}